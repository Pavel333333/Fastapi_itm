stages:
  - build
  - test
  - deploy

# Переменные для удобства (можно также использовать GitLab Variables)
variables:
  TEST_DB_NAME: $TEST_DB_NAME
  TEST_DB_USER: $TEST_DB_USER
  TEST_DB_PASSWORD: $TEST_DB_PASSWORD
  TEST_DB_HOST: "test_db"  # Указано, что TEST_DB_HOST заменён на test_db
  TEST_DB_PORT: "5432"

# Job для сборки Docker-образа
build-job:
  stage: build
  image: docker:24.0
  services:
    - docker:24.0-dind
  script:
    - docker build -t app_fastapi_itm:latest -f Dockerfile .
    - docker save app_fastapi_itm:latest > app_fastapi_itm.tar  # Сохраняем образ для передачи
  artifacts:
    paths:
      - app_fastapi_itm.tar  # Передаём образ в следующие job
  rules:
    - if: '$CI_COMMIT_REF_NAME == "main"'

# Job для запуска тестов
test-job:
  stage: test
  image: docker:24.0
  services:
    - name: postgres:17.2
      alias: test_db  # Соответствует TEST_DB_HOST
      env:
        POSTGRES_DB: $TEST_DB_NAME
        POSTGRES_USER: $TEST_DB_USER
        POSTGRES_PASSWORD: $TEST_DB_PASSWORD
  variables:
    MODE: "TEST"  # Устанавливаем режим TEST для проекта
  before_script:
    # Устанавливаем PostgreSQL-клиент для работы с базой
    - apk add --no-cache postgresql-client
    # Загружаем сохранённый образ из build-job
    - docker load < app_fastapi_itm.tar
  script:
    # Ждём, пока PostgreSQL запустится
    - until pg_isready -h test_db -p 5432 -U $TEST_DB_USER; do sleep 1; done
    # Копируем дамп базы и воссоздаём её
    - docker cp fastapi_itm_test_dump.sql test_db:/tmp/dump.sql
    - docker exec test_db psql -U $TEST_DB_USER -d $TEST_DB_NAME -f /tmp/dump.sql
    # Запускаем контейнер с приложением
    - docker run -d --name test_container --network=host -e MODE=TEST -e TEST_DB_NAME=$TEST_DB_NAME -e TEST_DB_USER=$TEST_DB_USER -e TEST_DB_PASSWORD=$TEST_DB_PASSWORD -e TEST_DB_HOST=$TEST_DB_HOST -e TEST_DB_PORT=$TEST_DB_PORT app_fastapi_itm:latest tail -f /dev/null
    # Копируем тестовые файлы в контейнер
    - docker cp app/tests/test_files/. test_container:/doc/documents_for_tests/
    # Устанавливаем pytest и запускаем тесты
    - docker exec test_container pip install pytest pytest-asyncio
    - docker exec test_container pytest -v /doc/app/tests/test_api.py
    # Останавливаем и удаляем контейнер
    - docker stop test_container
    - docker rm test_container
  dependencies:
    - build-job  # Тесты зависят от сборки образа
  artifacts:
    when: always
    paths:
      - pytest.log  # Логи тестов для отладки (если настроить вывод)
  rules:
    - if: '$CI_COMMIT_REF_NAME == "main"'

# Job для развёртывания (упрощённая версия)
deploy-job:
  stage: deploy
  image: docker:24.0
  script:
    - echo "Развёртывание на сервер (здесь должен быть реальный код деплоя)"
    - docker load < app_fastapi_itm.tar
    - docker tag app_fastapi_itm:latest myregistry/app_fastapi_itm:$CI_COMMIT_SHA
    - echo "Образ готов для деплоя: myregistry/app_fastapi_itm:$CI_COMMIT_SHA"
  dependencies:
    - test-job  # Деплой зависит от успешных тестов
  rules:
    - if: '$CI_COMMIT_REF_NAME == "main"'